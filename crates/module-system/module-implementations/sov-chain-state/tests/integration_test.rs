use std::convert::Infallible;

use sov_chain_state::{
    BlockGasInfo, ChainState, ChainStateConfig, StateTransition, TransitionInProgress,
};
use sov_mock_da::{MockBlock, MockBlockHeader, MockDaSpec, MockValidityCond};
use sov_mock_zkvm::MockCodeCommitment;
use sov_modules_api::da::Time;
use sov_modules_api::runtime::capabilities::mocks::MockKernel;
use sov_modules_api::{Gas, GasArray, KernelModule, KernelWorkingSet, Spec, StateCheckpoint};
use sov_prover_storage_manager::SimpleStorageManager;
use sov_state::{Storage, StorageRoot};
use sov_test_utils::{TestSpec, TestStorageSpec as StorageSpec};

const INITIAL_BASE_FEE_PER_GAS: [u64; 2] = [100, 100];
const NUM_ROUNDS: u8 = 4;

#[derive(Clone, Debug)]
struct TestBatchInfo {
    pub gas_to_use: <TestSpec as Spec>::Gas,
    pub validity_cond: MockValidityCond,
}

/// Values generated by the simulation of the chain state after each round of execution.
struct ChainStateExecutionValues {
    /// The state root before the state transition
    pub pre_state_root: StorageRoot<StorageSpec>,
    /// The time at which the state transition is executed
    pub time: Time,
    /// The base fee per gas computed for the new state transition
    pub computed_base_fee_per_gas: <<TestSpec as Spec>::Gas as Gas>::Price,
    /// The base fee per gas of the previous state transition
    pub prev_base_fee_per_gas: <<TestSpec as Spec>::Gas as Gas>::Price,
    /// The gas used by the previous state transition
    pub prev_gas_used: Option<<TestSpec as Spec>::Gas>,
}

type InitVars = (
    ChainState<TestSpec, MockDaSpec>,
    StorageRoot<StorageSpec>,
    SimpleStorageManager<StorageSpec>,
);

/// Helper function that initializes the hooks test. It creates and configures a simple chain state with [`INITIAL_BASE_FEE_PER_GAS`] base fee per gas.
/// Then it runs and commits the genesis state and returns a [`ChainState`] object,  the `genesis_root` (as a [`StorageRoot`]) and the `storage` (which is a [`ProverStorage`]).
fn init_test() -> Result<InitVars, Infallible> {
    // The initial height can be any value.
    // Initialize the module.
    let tmpdir = tempfile::tempdir().unwrap();

    let mut storage_manager = SimpleStorageManager::new(tmpdir.path());
    let storage = storage_manager.create_storage();
    let mut state_checkpoint = StateCheckpoint::new(storage.clone());

    let chain_state = ChainState::<TestSpec, MockDaSpec>::default();
    let config = ChainStateConfig {
        current_time: Default::default(),
        genesis_da_height: 0,
        inner_code_commitment: MockCodeCommitment::default(),
        outer_code_commitment: MockCodeCommitment::default(),
    };

    // Genesis, initialize and then commit the state
    chain_state
        .genesis_unchecked(
            &config,
            &mut KernelWorkingSet::uninitialized(&mut state_checkpoint),
        )
        .unwrap();
    let (reads_writes, _, witness) = state_checkpoint.freeze();
    let (genesis_root, change_set) = storage
        .validate_and_materialize(reads_writes, &witness)
        .unwrap();
    storage_manager.commit(change_set);
    let storage = storage_manager.create_storage();

    // Computes the initial, post genesis, working set
    let mut base_checkpoint = StateCheckpoint::new(storage.clone());

    // Check the slot number before any changes to the state.
    let mock_kernel: MockKernel<TestSpec, MockDaSpec> = MockKernel::new(0, 0);
    let initial_height = chain_state.true_slot_number(&mut KernelWorkingSet::from_kernel(
        &mock_kernel,
        &mut base_checkpoint,
    ))?;

    let mut working_set = KernelWorkingSet::from_kernel(&mock_kernel, &mut base_checkpoint);

    // Check that the genesis state variables are correctly initialized.
    assert_eq!(initial_height, 0, "The initial height was not computed");
    assert_eq!(
        chain_state.get_time(&mut working_set)?,
        Default::default(),
        "The time was not initialized to default value"
    );

    Ok((chain_state, genesis_root, storage_manager))
}

// Check that the state transition in progress has been stored
fn check_transition_in_progress(
    round_num: u8,
    computed_base_fee_per_gas: &<<TestSpec as Spec>::Gas as Gas>::Price,
    chain_state: &ChainState<TestSpec, MockDaSpec>,
    kernel_working_set: &mut KernelWorkingSet<TestSpec>,
) -> Result<(), Infallible> {
    let new_tx_in_progress: TransitionInProgress<TestSpec, MockDaSpec> = chain_state
        .get_in_progress_transition(kernel_working_set)?
        .unwrap();

    let expected_gas_info = BlockGasInfo::new(
        ChainState::<TestSpec, MockDaSpec>::initial_gas_limit(),
        computed_base_fee_per_gas.clone(),
    );

    assert_eq!(
        new_tx_in_progress,
        TransitionInProgress::<TestSpec, MockDaSpec>::new(
            [round_num; 32].into(),
            MockValidityCond { is_valid: true },
            expected_gas_info
        ),
        "The new transition has not been correctly stored"
    );

    Ok(())
}

/// Simulates one round of [`ChainState`] execution.
/// Simply calls the [`ChainState::begin_slot_hook`] and [`ChainState::end_slot_hook`] hooks successively
/// for a [`MockBlock`] whose header has a height of `round_num`, a creation time set to [`Time::now`],
/// a previous hash of `[round_num - 1; 32]`, and a current hash of `[round_num; 32]`.
/// Returns the creation time embedded in the `slot_data` header and the new base fee per gas computed for the block execution.
fn simulate_chain_state_execution(
    round_num: u8,
    validity_cond: MockValidityCond,
    pre_state_root: &StorageRoot<StorageSpec>,
    gas_used: &<TestSpec as Spec>::Gas,
    chain_state: &ChainState<TestSpec, MockDaSpec>,
    kernel_working_set: &mut KernelWorkingSet<TestSpec>,
) -> Result<(Time, <<TestSpec as Spec>::Gas as Gas>::Price), Infallible> {
    // Sanity test: the round number matches the next height of the chain and so cannot be zero.
    assert!(round_num > 0);

    let slot_data = MockBlock {
        header: MockBlockHeader {
            prev_hash: [round_num - 1; 32].into(),
            hash: [round_num; 32].into(),
            height: round_num as u64,
            time: Time::now(),
        },
        validity_cond,
        batch_blobs: Default::default(),
        proof_blobs: Default::default(),
    };

    let computed_base_fee_per_gas = chain_state.begin_slot_hook(
        &slot_data.header,
        &slot_data.validity_cond,
        pre_state_root,
        kernel_working_set,
    );

    check_transition_in_progress(
        round_num,
        &computed_base_fee_per_gas,
        chain_state,
        kernel_working_set,
    )?;

    chain_state.end_slot_hook(gas_used, kernel_working_set);

    Ok((slot_data.header.time, computed_base_fee_per_gas))
}

/// Checks that the [`ChainState`] time state variable is correctly updated after each round of execution.
fn check_time_updates(
    time: Time,
    chain_state: &ChainState<TestSpec, MockDaSpec>,
    kernel_working_set: &mut KernelWorkingSet<TestSpec>,
) -> Result<(), Infallible> {
    assert_ne!(
        chain_state.get_time(kernel_working_set)?,
        Default::default(),
        "The time must be updated"
    );

    assert_eq!(
        chain_state.get_time(kernel_working_set)?,
        time,
        "The time was not updated in the hook"
    );

    Ok(())
}

/// Checks that the [`ChainState`] state transitions are correctly stored after each round of execution.
fn check_transitions_stored(
    round_num: u8,
    pre_state_root: StorageRoot<StorageSpec>,
    prev_gas_used: Option<<TestSpec as Spec>::Gas>,
    prev_base_fee_per_gas: &<<TestSpec as Spec>::Gas as Gas>::Price,
    chain_state: &ChainState<TestSpec, MockDaSpec>,
    kernel_working_set: &mut KernelWorkingSet<TestSpec>,
) -> Result<(), Infallible> {
    // Sanity test: the round number matches the next height of the chain and so cannot be zero.
    assert!(round_num > 0);

    if round_num == 1 {
        // Check that the genesis root hash has been stored correctly
        let stored_root = chain_state.get_genesis_hash(kernel_working_set)?.unwrap();

        assert_eq!(stored_root, pre_state_root, "Genesis hashes don't match");
    } else {
        // Check that the last state transition has been stored in the `historical_transitions` map.
        let last_tx_stored: StateTransition<TestSpec, MockDaSpec> = chain_state
            .get_historical_transitions((round_num - 1) as u64, kernel_working_set.inner)?
            .unwrap();

        let mut expected_gas_info = BlockGasInfo::new(
            ChainState::<TestSpec, MockDaSpec>::initial_gas_limit(),
            prev_base_fee_per_gas.clone(),
        );

        expected_gas_info.update_gas_used(
            prev_gas_used
                .expect("The previous gas used should be available")
                .clone(),
        );

        let expected_tx_stored: StateTransition<TestSpec, MockDaSpec> = StateTransition::new(
            [round_num - 1; 32].into(),
            pre_state_root,
            MockValidityCond { is_valid: true },
            expected_gas_info,
        );

        assert_eq!(
            last_tx_stored, expected_tx_stored,
            "The stored transition data must match"
        );
    }

    Ok(())
}

/// Checks that the [`ChainState`] has correctly been updated after each round of execution.
fn post_simulation_state_checks(
    round_num: u8,
    exec_values: &ChainStateExecutionValues,
    chain_state: &ChainState<TestSpec, MockDaSpec>,
    kernel_working_set: &mut KernelWorkingSet<TestSpec>,
) -> Result<(), Infallible> {
    // Check that the slot number has been updated
    let new_height_storage = chain_state.true_slot_number(kernel_working_set)?;

    assert_eq!(
        new_height_storage, round_num as u64,
        "The new height did not update"
    );

    // Check that the time state variable has been updated
    check_time_updates(exec_values.time.clone(), chain_state, kernel_working_set)?;

    // Check that the state transitions have been correctly stored
    check_transitions_stored(
        round_num,
        exec_values.pre_state_root,
        exec_values.prev_gas_used.clone(),
        &exec_values.prev_base_fee_per_gas,
        chain_state,
        kernel_working_set,
    )?;

    // Check that the base fee per gas has been updated and correctly computed
    if round_num > 1 {
        let mut gas_info = BlockGasInfo::new(
            ChainState::<TestSpec, MockDaSpec>::initial_gas_limit(),
            exec_values.prev_base_fee_per_gas.clone(),
        );
        gas_info.update_gas_used(
            exec_values
                .prev_gas_used
                .clone()
                .expect("The previous gas used should be available"),
        );
        assert_eq!(
            ChainState::<TestSpec, MockDaSpec>::compute_base_fee_per_gas(&gas_info),
            exec_values.computed_base_fee_per_gas,
            "The base fee per gas has not been updated correctly"
        );
    }

    Ok(())
}

/// Builds a new [`KernelWorkingSet`] that has `round_num` as the true and visible slot number.
fn build_kernel_working_set(
    round_num: u8,
    state_checkpoint: &mut StateCheckpoint<TestSpec>,
) -> KernelWorkingSet<TestSpec> {
    let mock_kernel: MockKernel<TestSpec, MockDaSpec> =
        MockKernel::new((round_num - 1) as u64, (round_num - 1) as u64);
    KernelWorkingSet::from_kernel(&mock_kernel, state_checkpoint)
}

/// Simulates the execution of the chain state from genesis to `num_rounds = len(test_batch_infos)` slots.
/// For each round, this method calls the [`ChainState::begin_slot_hook`] and [`ChainState::end_slot_hook`] hooks successively
/// for a [`MockBlock`] whose header has a height of `round_num`, a creation time set to [`Time::now`],
/// a previous hash of `[round_num - 1; 32]`, and a current hash of `[round_num; 32]`.
/// Then it checks that the [`ChainState`] state variables have been correctly updated and commits the writes to the storage.
fn simulate_chain_state_execution_n_rounds(
    genesis_root: StorageRoot<StorageSpec>,
    test_batch_infos: Vec<TestBatchInfo>,
    chain_state: &ChainState<TestSpec, MockDaSpec>,
    mut storage_manager: SimpleStorageManager<StorageSpec>,
) -> Result<(), Infallible> {
    assert!(!test_batch_infos.is_empty());

    let mut pre_state_root = genesis_root;
    let mut prev_gas_used = None;
    let mut prev_base_fee_per_gas: <<TestSpec as Spec>::Gas as Gas>::Price =
        INITIAL_BASE_FEE_PER_GAS.into();

    for (mut round_num, test_batch_info) in test_batch_infos.into_iter().enumerate() {
        // We need to increment the round number by one because the counter starts at zero.
        round_num += 1;

        let storage = storage_manager.create_storage();
        let mut state_checkpoint = StateCheckpoint::new(storage.clone());
        let mut kernel_working_set =
            build_kernel_working_set(round_num as u8, &mut state_checkpoint);

        let (time, computed_base_fee_per_gas) = simulate_chain_state_execution(
            round_num as u8,
            test_batch_info.validity_cond,
            &pre_state_root,
            &test_batch_info.gas_to_use,
            chain_state,
            &mut kernel_working_set,
        )?;

        post_simulation_state_checks(
            round_num as u8,
            &ChainStateExecutionValues {
                pre_state_root,
                time,
                computed_base_fee_per_gas: computed_base_fee_per_gas.clone(),
                prev_base_fee_per_gas,
                prev_gas_used,
            },
            chain_state,
            &mut kernel_working_set,
        )?;

        // Materialize the new state (which produces a new root hash)
        let (reads_writes, _, witness) = state_checkpoint.freeze();
        let (post_state_root, change_set) = storage
            .validate_and_materialize(reads_writes, &witness)
            .unwrap();

        storage_manager.commit(change_set);
        prev_gas_used = Some(test_batch_info.gas_to_use);
        prev_base_fee_per_gas = computed_base_fee_per_gas;
        pre_state_root = post_state_root;
    }

    Ok(())
}

/// This test simulates the execution of the chain state for genesis and one slot after. It checks that the
/// chain state updates its state properly with the invocation of the [`ChainState::begin_slot_hook`] and [`ChainState::end_slot_hook`] hooks.  
///
/// The gas is set at the initial gas target for each block so that the gas is not elastic.
///
/// For more complete integration tests, feel free to have a look at the integration tests folder.
#[test]
fn test_simple_chain_state_one_round_at_gas_target() -> Result<(), Infallible> {
    // Initialize the test: create and configure a simple chain state with [`INITIAL_BASE_FEE_PER_GAS`] base fee per gas.
    // Then run and commit the genesis state and return the `storage_manager` and `genesis_root`.
    let (chain_state, genesis_root, storage_manager) = init_test()?;

    // Then simulate a transaction execution: call the begin_slot hook on a mock slot_data.
    simulate_chain_state_execution_n_rounds(
        genesis_root,
        vec![TestBatchInfo {
            gas_to_use: ChainState::<TestSpec, MockDaSpec>::initial_gas_target(),
            validity_cond: MockValidityCond { is_valid: true },
        }],
        &chain_state,
        storage_manager,
    )
}

/// This test simulates the execution of the chain state for genesis and one slot after. It checks that the
/// chain state updates its state properly with the invocation of the [`ChainState::begin_slot_hook`] and [`ChainState::end_slot_hook`] hooks.  
///
/// The gas is set at the initial gas target plus a constant offset.
///
/// For more complete integration tests, feel free to have a look at the integration tests folder.
#[test]
fn test_simple_chain_state_one_round() -> Result<(), Infallible> {
    const GAS_OFFSET: u64 = 100;

    // Initialize the test: create and configure a simple chain state with [`INITIAL_BASE_FEE_PER_GAS`] base fee per gas.
    // Then run and commit the genesis state and returns the `storage` and `genesis_root`.
    let (chain_state, genesis_root, storage_manager) = init_test()?;

    // Then simulate a transaction execution: call the begin_slot hook on a mock slot_data.
    simulate_chain_state_execution_n_rounds(
        genesis_root,
        vec![TestBatchInfo {
            gas_to_use: ChainState::<TestSpec, MockDaSpec>::initial_gas_target()
                .scalar_add(GAS_OFFSET)
                .clone(),
            validity_cond: MockValidityCond { is_valid: true },
        }],
        &chain_state,
        storage_manager,
    )
}

/// This test simulates the execution of the chain state for genesis and [`NUM_ROUNDS`] slots after. It checks that the
/// chain state updates its state properly with the invocation of the [`ChainState::begin_slot_hook`] and [`ChainState::end_slot_hook`] hooks.  
///
/// The gas is set at the initial gas target for each block so that the gas is not elastic.
///
/// For more complete integration tests, feel free to have a look at the integration tests folder.
#[test]
fn test_simple_chain_state_at_gas_target() -> Result<(), Infallible> {
    // Initialize the test: create and configure a simple chain state with [`INITIAL_BASE_FEE_PER_GAS`] base fee per gas.
    // Then run and commit the genesis state and returns the `storage` and `genesis_root`.
    let (chain_state, genesis_root, storage_manager) = init_test()?;

    let test_batch_info = vec![
        TestBatchInfo {
            gas_to_use: ChainState::<TestSpec, MockDaSpec>::initial_gas_target(),
            validity_cond: MockValidityCond { is_valid: true },
        };
        NUM_ROUNDS as usize
    ];

    // Then simulate a transaction execution: call the begin_slot hook on a mock slot_data.
    simulate_chain_state_execution_n_rounds(
        genesis_root,
        test_batch_info,
        &chain_state,
        storage_manager,
    )
}

/// This test simulates the execution of the chain state for genesis and [`NUM_ROUNDS`] slots after. It checks that the
/// chain state updates its state properly with the invocation of the [`ChainState::begin_slot_hook`] and [`ChainState::end_slot_hook`] hooks.  
///
/// The gas used varies from round to round, so the base fee per gas is updated each round.
///
/// For more complete integration tests, feel free to have a look at the integration tests folder.
#[test]
fn test_simple_chain_state() -> Result<(), Infallible> {
    // Initialize the test: create and configure a simple chain state with [`INITIAL_BASE_FEE_PER_GAS`] base fee per gas.
    // Then run and commit the genesis state and returns the `storage` and `genesis_root`.
    let (chain_state, genesis_root, storage_manager) = init_test()?;

    let mut test_batch_info = vec![
        TestBatchInfo {
            gas_to_use: ChainState::<TestSpec, MockDaSpec>::initial_gas_target(),
            validity_cond: MockValidityCond { is_valid: true },
        };
        NUM_ROUNDS as usize
    ];

    let test_batch_info = test_batch_info
        .iter_mut()
        .enumerate()
        .map(|(i, test_batch_info)| TestBatchInfo {
            gas_to_use: test_batch_info
                .gas_to_use
                .scalar_add(i as u64 * 100)
                .clone(),
            validity_cond: test_batch_info.validity_cond,
        })
        .collect();

    // Then simulate a transaction execution: call the begin_slot hook on a mock slot_data.
    simulate_chain_state_execution_n_rounds(
        genesis_root,
        test_batch_info,
        &chain_state,
        storage_manager,
    )
}

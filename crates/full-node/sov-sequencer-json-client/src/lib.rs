//! A client for the Sovereign SDK sequencer JSON API, generated by
//! [`progenitor`].

use base64::prelude::*;
use borsh::BorshSerialize;
use futures::stream::BoxStream;
use futures::StreamExt;
use sov_rollup_interface::common::HexHash;
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::{Error as WsError, Message};

pub extern crate tokio_tungstenite;

progenitor::generate_api!(
    spec = "../sov-sequencer/openapi-v3.yaml",
    derives = [Debug, Clone, PartialEq, Eq],
);

/// Custom WebSocket extensions and extra utilities, in addition to the
/// [`Client`] generated by [`progenitor`].
impl Client {
    /// Sends a transaction to the sequencer for immediate publication.
    pub async fn publish_batch_with_serialized_txs<Tx: BorshSerialize>(
        &self,
        txs: &[Tx],
    ) -> Result<(), Error<types::PublishBatchResponse>> {
        for tx in txs {
            let tx_bytes =
                borsh::to_vec(tx).map_err(|err| Error::InvalidRequest(err.to_string()))?;
            let tx_b64 = BASE64_STANDARD.encode(&tx_bytes);

            self.accept_tx(&types::AcceptTxBody { body: tx_b64 })
                .await
                .map_err(|err| Error::PreHookError(err.to_string()))?;
        }

        self.publish_batch(&types::PublishBatchBody {
            transactions: vec![],
        })
        .await?;

        Ok(())
    }

    pub async fn subscribe_to_tx_status_updates(
        &self,
        tx_hash: [u8; 32],
    ) -> Result<BoxStream<anyhow::Result<types::TxInfo>>, WsError> {
        let url = format!(
            "{}/txs/{}/ws",
            // The base URL can't be used for WebSocket connections; we need to
            // change the protocol.
            self.baseurl().replace("http://", "ws://"),
            HexHash::new(tx_hash)
        );

        let (ws, _) = connect_async(url).await?;

        Ok(ws
            .filter_map(|msg| async {
                match msg {
                    Ok(Message::Text(text)) => match serde_json::from_str(&text) {
                        Ok(tx_status) => Some(Ok(tx_status)),
                        Err(err) => Some(Err(anyhow::anyhow!("{}", err))),
                    },
                    // Non-text messages are ignored because we don't expect them to ever be sent from the server.
                    Ok(_) => None,
                    // Errors are not handled here but passed to the caller.
                    Err(err) => Some(Err(anyhow::anyhow!("{}", err))),
                }
            })
            .boxed())
    }
}

//! A client for the Sovereign SDK ledger JSON API, generated by
//! [`progenitor`].

use std::slice::Iter;

use anyhow::Context;
use base64::prelude::*;
use futures::stream::BoxStream;
use futures::StreamExt;
use sov_rollup_interface::rpc::FinalityStatus;
use sov_rollup_interface::zk::aggregated_proof;
use tokio_tungstenite::connect_async;
use tokio_tungstenite::tungstenite::{Error as WsError, Message};
pub extern crate tokio_tungstenite;

pub type WsSubscription<T> = Result<BoxStream<'static, anyhow::Result<T>>, WsError>;

progenitor::generate_api!(
    spec = "../sov-ledger-apis/openapi-v3.yaml",
    derives = [Debug, Clone, PartialEq],
);

/// Custom WebSocket extensions and extra utilities, in addition to the
/// [`Client`] generated by [`progenitor`].
impl Client {
    pub async fn subscribe_slots(&self) -> WsSubscription<types::Slot> {
        self.subscribe_to_ws("/slots/latest/ws").await
    }

    pub async fn subscribe_aggregated_proof(&self) -> WsSubscription<types::AggregatedProof> {
        self.subscribe_to_ws("/aggregated-proofs/latest/ws").await
    }

    async fn subscribe_to_ws<T: serde::de::DeserializeOwned>(
        &self,
        path: &str,
    ) -> WsSubscription<T> {
        // The base URL can't be used for WebSocket connections; we need to
        // change the protocol.
        let url = format!("{}{}", self.baseurl(), path).replace("http://", "ws://");

        let (ws, _) = connect_async(url).await?;

        Ok(ws
            .filter_map(|msg| async {
                match msg {
                    Ok(Message::Text(text)) => match serde_json::from_str(&text) {
                        Ok(tx_status) => Some(Ok(tx_status)),
                        Err(err) => Some(Err(anyhow::anyhow!(
                            "failed to deserialize JSON {} into type: {}",
                            text,
                            err
                        ))),
                    },
                    Ok(Message::Binary(msg)) => {
                        tracing::warn!(
                            ?msg,
                            "Received unsupported binary message from WebSocket connection"
                        );
                        None
                    }
                    // All other kinds of messages are ignored because
                    // `tokio-tungstenite` ought to handle all
                    // meta-communication messages (ping, pong, clonse) for us anyway.
                    Ok(_) => None,
                    // Errors are not handled here but passed to the caller.
                    Err(err) => Some(Err(anyhow::anyhow!("{}", err))),
                }
            })
            .boxed())
    }
}

impl TryInto<aggregated_proof::AggregatedProof> for types::AggregatedProof {
    type Error = anyhow::Error;

    fn try_into(self) -> anyhow::Result<aggregated_proof::AggregatedProof> {
        let public_data = self.public_data;
        Ok(aggregated_proof::AggregatedProof::new(
            aggregated_proof::SerializedAggregatedProof {
                raw_aggregated_proof: decode_b64(&self.proof)?,
            },
            aggregated_proof::AggregatedProofPublicData {
                validity_conditions: decode_b64_vec(public_data.validity_conditions.iter())?,
                rewarded_addresses: decode_b64_vec(public_data.rewarded_addresses.iter())?,
                initial_slot_number: public_data.initial_slot_number,
                final_slot_number: public_data.final_slot_number,
                genesis_state_root: decode_b64(&public_data.genesis_state_root)?,
                initial_state_root: decode_b64(&public_data.initial_state_root)?,
                final_state_root: decode_b64(&public_data.final_state_root)?,
                initial_slot_hash: decode_b64(&public_data.initial_slot_hash)?,
                final_slot_hash: decode_b64(&public_data.final_slot_hash)?,
                code_commitment: aggregated_proof::CodeCommitment(decode_b64(
                    &public_data.code_commitment,
                )?),
            },
        ))
    }
}

fn decode_b64_vec(itr: Iter<'_, String>) -> anyhow::Result<Vec<Vec<u8>>> {
    itr.map(|s| decode_b64(s)).collect()
}

fn decode_b64(data: &str) -> anyhow::Result<Vec<u8>> {
    BASE64_STANDARD
        .decode(data)
        .context("Failed to decode base64 data in aggregated proof response")
}

impl From<types::SlotFinalityStatus> for FinalityStatus {
    fn from(value: types::SlotFinalityStatus) -> Self {
        match value {
            types::SlotFinalityStatus::Finalized => FinalityStatus::Finalized,
            types::SlotFinalityStatus::Pending => FinalityStatus::Pending,
        }
    }
}
